try:
    import impedance
    print("✅ 'impedance' 이미 설치되어 있습니다.")
except ImportError:
    !pip install -q impedance
    import impedance
    print("✅ 'impedance' 설치 완료.")

from impedance import preprocessing
frequencies, Z = preprocessing.readCSV('/content/drive/MyDrive/Science comment/freq_real_imag_degfreq.csv')

# Chemical capacitance 연결 X

from impedance.models.circuits import CustomCircuit
from impedance.models.circuits.fitting import set_default_bounds
from impedance.visualization import plot_nyquist
import matplotlib.pyplot as plt

# 1) 회로 정의 및 초기값
circuit_str = 'R0-p(R1,CPE1)-p(R2-Wo1,CPE2)'
initial_guess = [10, 150, 1e-3, 0.9, 100, 100, 10, 1e-3, 0.9]

model = CustomCircuit(circuit_str, initial_guess=initial_guess)

# 2) 기본 bounds 생성 (+ 필요시 수정)
lb, ub = set_default_bounds(model.circuit)

# 파라미터 인덱스 참조를 간단히
names, _ = model.get_param_names()
idx = {n: i for i, n in enumerate(names)}  # 예: idx['R2'], idx['Wo1_0'], idx['Wo1_1']

# --- 필요 시 예시 ---
# lb[idx['R2']], ub[idx['R2']] = 120, 160
# --------------------

# 3) 피팅 및 예측
model.fit(frequencies, Z, weight_by_modulus=True, bounds=(lb, ub))
Z_fit = model.predict(frequencies)

print(model)

# 4) Nyquist 플롯
fig, ax = plt.subplots()
plot_nyquist(Z, fmt='o', scale=1, ax=ax)
plot_nyquist(Z_fit, fmt='-', scale=1, ax=ax)
ax.legend(['Data', 'Fit'])
plt.show()

# Chemical capacitance를 병렬로 연결

from impedance.models.circuits import CustomCircuit
from impedance.models.circuits.fitting import set_default_bounds
from impedance.visualization import plot_nyquist
import matplotlib.pyplot as plt

# 1) 회로 정의 및 초기값
circuit_str = 'R0-p(R1,CPE1)-p(R2-p(Wo1,C1),CPE2)'
initial_guess = [10, 150, 1e-3, 0.9, 100, 100, 10, 1e-3, 1e-3, 0.9]

model = CustomCircuit(circuit_str, initial_guess=initial_guess)

# 2) 기본 bounds 생성 (+ 필요 시 수정)
lb, ub = set_default_bounds(model.circuit)

# 파라미터 인덱스 매핑(예: idx['R2'], idx['Wo1_0'], idx['Wo1_1'], idx['C1'] ...)
names, _ = model.get_param_names()
idx = {n: i for i, n in enumerate(names)}

# --- 필요 시 예시 ---
# lb[idx['R2']], ub[idx['R2']] = 120, 160
# --------------------

# 3) 피팅 및 예측 (bounds 명시)
model.fit(frequencies, Z, weight_by_modulus=True, bounds=(lb, ub))
Z_fit = model.predict(frequencies)

print(model)

# 4) Nyquist 플롯
fig, ax = plt.subplots()
plot_nyquist(Z, fmt='o', scale=1, ax=ax)
plot_nyquist(Z_fit, fmt='-', scale=1, ax=ax)
ax.legend(['Data', 'Fit'])
plt.show()

# 5) 피팅된 파라미터를 딕셔너리로 저장
fitted_params = dict(zip(names, model.parameters_))

# === t_target 통일 유틸 ===
import numpy as np

def _lowest_peak_freq_continuous(f, Z):
    """-Im{Z}(vs log f)의 연속 최대 주파수들 중 최저값(Hz) 반환. 없으면 None."""
    f = np.asarray(f, float)
    Z = np.asarray(Z, complex)
    if f.size < 3:
        return None
    order = np.argsort(f)
    f = f[order]
    x = np.log(f)
    y = -Z[order].imag
    d = np.gradient(y, x)
    cand = np.where((d[:-1] > 0) & (d[1:] < 0))[0] + 1
    if cand.size == 0:
        return None

    peaks = []
    for c in cand:
        i0, i1, i2 = max(c-1, 0), c, min(c+1, len(x)-1)
        idx = np.unique([i0, i1, i2])
        if idx.size < 3:
            j = np.argmax(y[max(c-1, 0):min(c+2, len(y))]) + max(c-1, 0)
            peaks.append(float(f[j]))
            continue
        xt, yt = x[idx], y[idx]
        a, b, c0 = np.polyfit(xt, yt, 2)
        if not np.isfinite(a) or a >= 0:
            # 퇴화/볼록 → 이산 최대 폴백
            j = np.argmax(yt)
            fpk = float(np.exp(xt[j]))
        else:
            xpk = -b/(2*a)
            if (xpk < xt.min()) or (xpk > xt.max()) or (not np.isfinite(xpk)):
                j = np.argmax(yt)
                fpk = float(np.exp(xt[j]))
            else:
                fpk = float(np.exp(xpk))
        peaks.append(fpk)
    return float(np.min(peaks)) if peaks else None

def compute_t_target(frequencies, Z_mod, default=0.02):
    """
    수정(modified) 회로의 Z_mod와 주파수 배열로부터
    t_target = 1/(2π f_lowest_peak) 계산. 실패 시 default 반환.
    반환: (t_target, lowest_freq_mod or None)
    """
    f0 = _lowest_peak_freq_continuous(frequencies, Z_mod)
    if (f0 is not None) and np.isfinite(f0) and (f0 > 0):
        return 1.0/(2*np.pi*f0), f0
    return float(default), None

F_PEAK = np.logspace(-2, 2, 10000)

# Chemical capacitance 병렬연결 EIS의 공진(resonant) 주파수 계산
# (피팅된 회로 객체: 'circuit' 변수에 존재한다고 가정; 없으면 'model'도 허용)

import numpy as np

_circuit = locals().get('circuit', locals().get('model'))
if _circuit is not None and getattr(_circuit, 'parameters_', None) is not None:
    # 1) 시뮬레이션용 주파수 축
    frequencies_sim = np.logspace(-5, 5, 1000)
    f_sim = frequencies_sim.astype(float)
    w_sim = 2 * np.pi * f_sim

    # 2) 피팅 파라미터 로드
    names, _ = _circuit.get_param_names()
    p = dict(zip(names, _circuit.parameters_))
    R0_fit, R1_fit, R2_fit = p['R0'], p['R1'], p['R2']
    Z0_fit, tau_fit = p['Wo1_0'], p['Wo1_1']
    C1_fit_orig = p['C1']
    Q1_fit, n1_fit = p['CPE1_0'], p['CPE1_1']
    Q2_fit, n2_fit = p['CPE2_0'], p['CPE2_1']

    # 3) 보조 정보
    info = globals().get('info', {})
    N_cauer = info.get('Cauer_N', 80)

    # 4) Wo -> Cauer ladder, 개방단 임피던스
    Rk_cauer, Ck_cauer = warburg_to_cauer_uniform(Z0_fit, tau_fit, N_cauer)
    Z_w_all_mod_sim = Z_cauer_open(w_sim, Rk_cauer, Ck_cauer, N_cauer)

    # 5) 첫 번째 가지: p(R1, CPE1) → Hsu–Mansfeld Ceq로 치환
    C1eq_orig = hm_ceq(Q1_fit, n1_fit, R1_fit)
    Z_R1C1eq_orig_sim = Z_parallel(R1_fit, Z_cap(C1eq_orig, w_sim))

    # 6) 두 번째 블록: p( R2 + p(Wo, C1_fit_orig) , C2eq_orig )
    Z_p_Wo_C1_orig_all_sim = Z_parallel(Z_w_all_mod_sim, Z_cap(C1_fit_orig, w_sim))
    Z_branchA_all_mod_sim = Z_series(R2_fit, Z_p_Wo_C1_orig_all_sim)
    C2eq_orig = info.get('C2eq(F)_HsuMansfeld')  # 없으면 이후 계산에서 오류 발생(원 코드 동작 동일)
    Z_block2_mod_current_sim = Z_parallel(Z_branchA_all_mod_sim, Z_cap(C2eq_orig, w_sim))

    # 7) 전체 수정 모델 임피던스
    Z_mod_sim = Z_series(R0_fit, Z_R1C1eq_orig_sim, Z_block2_mod_current_sim)

    # 8) -Im{Z}의 국소 최대값(반원 피크) 탐지
    Z_imaginary_mod_sim = -Z_mod_sim.imag
    d = np.gradient(Z_imaginary_mod_sim, np.log(frequencies_sim))  # d(-ImZ)/d(log f)

    # 부호 변화: (+) → (−)
    cand = np.where((d[:-1] > 0) & (d[1:] < 0))[0] + 1
    local_maxima_indices_mod_sim = np.where(
        np.abs(d[cand - 1]) < np.abs(d[cand]), cand - 1, cand
    ).tolist()

    peak_frequencies_list_mod_sim = []
    if local_maxima_indices_mod_sim:
        print("Modified 회로 시뮬레이션에서 반원 피크 주파수:")
        for i in local_maxima_indices_mod_sim:
            f_pk = frequencies_sim[i]
            z_pk = Z_imaginary_mod_sim[i]
            print(f"  Frequency: {f_pk:.2f} Hz, -Z_imag: {z_pk:.2f} Ohm")
            peak_frequencies_list_mod_sim.append(f_pk)
        lowest_freq_mod = min(peak_frequencies_list_mod_sim)
    else:
        lowest_freq_mod = None
        print("수정된 시뮬레이션 임피던스에서 국소 최대(-ImZ) 미검출.")

else:
    lowest_freq_mod = None
    print("회로가 아직 피팅되지 않았습니다. 먼저 피팅을 수행하세요.")

if lowest_freq_mod is not None:
    print(f"\nLowest resonant frequency (modified): {lowest_freq_mod:.4f} Hz")
else:
    print("\n최저 공진 주파수를 결정할 수 없습니다.")

